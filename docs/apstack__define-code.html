<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Sat Mar  7 23:17:56 2015 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>apstack__define.pro (Documentation for /Users/aram/git/APlib/core/)</title>

    
    <link rel="stylesheet" type="text/css" media="all"
          href="idldoc-resources/main.css" />
    <link rel="stylesheet" type="text/css" media="print"
          href="idldoc-resources/main-print.css" />
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="apstack__define.pro (Documentation for /Users/aram/git/APlib/core/)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;==============================================================================</span>
<span class="comments">; :: APSTACK ::</span>
<span class="comments">;+=============================================================================</span>
<span class="comments">;</span>
<span class="comments">; This class is an object-oriented wrapper around a basic stack.</span>
<span class="comments">; The undelying structure is an array.</span>
<span class="comments">; Values are added to the beginning and popped from the beginning.</span>
<span class="comments">;</span>
<span class="comments">; :Author:</span>
<span class="comments">;    Aram Panasenco (panasencoaram@gmail.com)</span>
<span class="comments">;</span>
<span class="comments">;-=============================================================================</span>

<span class="comments">;==============================================================================</span>
<span class="comments">;    APSTACK::INIT</span>
<span class="comments">;+=============================================================================</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Initializes an apStack object.</span>
<span class="comments">;</span>
<span class="comments">; :Returns:</span>
<span class="comments">;    Boolean success value (1/0)</span>
<span class="comments">;-=============================================================================</span>
<a id="apStack::init:source"></a>function apStack::init
	self.nElements = 0L
	return, 1B
end


<span class="comments">;==============================================================================</span>
<span class="comments">;    APSTACK::PUSH</span>
<span class="comments">;+=============================================================================</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Pushes a value to the beginning of the stack</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    var : required</span>
<span class="comments">;      The value being pushed onto the stack</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    TO_END : optional, type=boolean</span>
<span class="comments">;      Set this keyword to push the value onto the end of the stack (pushing</span>
<span class="comments">;      to the beginning is the default behavior).</span>
<span class="comments">;</span>
<span class="comments">;-=============================================================================</span>
<a id="apStack::push:source"></a>pro apStack::push, var, TO_END=toEnd
	
	<span class="comments">;Return to caller in case of an error</span>
	on_error, 2
	
	if (self.nElements eq 0) then begin
		<span class="comments">;Create the data</span>
		self.pData = ptr_new(var)
	endif else begin
		if keyword_set(toEnd) then begin
			<span class="comments">;Add the variable to the end of the data</span>
			*self.pData = [*self.pData, var]
		endif else begin
			<span class="comments">;Add the variable to the beginning of the data</span>
			*self.pData = [var,*self.pData]
		endelse
	endelse
	
	self.nElements++
end


<a id="apStack::read:source"></a>function apStack::read, index, ALL=all
	
	<span class="comments">;Return to caller in case of an error</span>
	on_error, 2
	
	<span class="comments">;Check if there are any elements to read</span>
	if (self.nElements eq 0) then begin
		message, "Can't read: No elements in stack."
	endif
	
	if (keyword_set(all)) then begin
		<span class="comments">;Return all elements</span>
		return, *self.pData
	endif else begin
		<span class="comments">;Sanity-check the index</span>
		if n_elements(index) ne 1 then index = 0
		if index lt 0 then index = 0
		if index gt self.nElements-1 then index = self.nElements-1
		<span class="comments">;Return the element specified by index</span>
		return, (*self.pData)[index]
	endelse
end


<a id="apStack::write:source"></a>pro apStack::write, value, index
	
	<span class="comments">;Sanity-check the index</span>
	if n_elements(index) ne 1 then index = 0
	if index lt 0 then index = 0
	<span class="comments">;Check for push or write</span>
	if index gt self.nElements-1 then begin
		self -> push, value, /to_end
	endif else begin
		<span class="comments">;Write the value to the index</span>
		pData = *self.pData
		pData[index] = value
		*self.pData = pData
	endelse
	
end


<a id="apStack::pop:source"></a>function apStack::pop
	
	on_error, 2
	
	<span class="comments">;Check for stack underflow</span>
	if (self.nElements eq 0) then begin
		message, "Can't pop: No elements in stack."
	endif
	
	<span class="comments">;Find the value of the first element in the stack</span>
	popElement = (*self.pData)[0]
	
	if (self.nElements gt 1) then begin
		<span class="comments">;Remove the first element from the stack</span>
		(*self.pData) = (*self.pData)[1:self.nElements-1]
		self.nElements--
	endif else begin
		<span class="comments">;No more elements to remove, clear the data</span>
		self -> clear
	endelse
	
	<span class="comments">;Return the first element</span>
	return, popElement
end


<a id="apStack::count:source"></a>function apStack::count
	return, self.nElements
end


<a id="apStack::clear:source"></a>pro apStack::clear
	
	<span class="comments">;Clear the data</span>
	ptr_free, self.pData
	
	<span class="comments">;Default the number of elements</span>
	self.nElements = 0
end


<a id="apStack::cleanup:source"></a>pro apStack::cleanup
	<span class="comments">;Destroy the data</span>
	ptr_free, self.pData
end


<span class="comments">;==============================================================================</span>
<span class="comments">;    APDATA__DEFINE</span>
<span class="comments">;+=============================================================================</span>
<span class="comments">; :Hidden:</span>
<span class="comments">;</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Definition procedure for the apStack class</span>
<span class="comments">;</span>
<span class="comments">;-=============================================================================</span>
<a id="apStack__define:source"></a>pro apStack__define
	class = { $
		apStack, $
		nElements: 0L, $
		pData: ptr_new() $
	}
end
</code>
    </div>
  </body>
</html>